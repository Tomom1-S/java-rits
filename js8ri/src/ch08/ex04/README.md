## 練習問題8.4

`Math.nextDown(x)` メソッドは、何らかのランダムな処理が x に正確に一致した場合に、
x よりも次に小さな浮動小数点数を返します。
これにより、返された数が x より小さいことが保証されます。
これは、本当に保証できるのでしょうか。
`double r = 1 - generator.nextDouble()` を考えてみてください。
この `generator` は、`java.util.Random` のインスタンスです。
`r` が、1になることはあるでしょうか。
すなわち、`generator.nextDouble()` が0を生成できるでしょうか。
ドキュメントによれば、それは0を含み、1未満の値を生成できるとなっています。
しかし、2^53個の浮動小数点数が存在することを考慮すると、0を得ることはあるのでしょうか。
実際、0を得ます。
乱数生成器は、次のシードを next(s) = s・m + *a* % *N* として計算します。
ここで、*m* = 25214903917、*a* = 11、*N* = 2^48 です。
m モジュロ N の逆は *v* = 246154705703781 です。
そして、結果として、シードの前の値を prev(*s*) = (*s* - *a*)・*v* % *N* として
計算することができます。
`double` を生成するために2つの乱数が生成されて、毎回、トップの26ビットと27ビットが使用されます。
*s* が0の場合、next(*s*) は11であり、それが私たちが得たいものです。
すなわち、2つの連続する数字の上位ビットが0です。
ここで、逆にやりなおして、*s* = prev(prev(prev(0))) から始めましょう。
`Random` のコンストラクタは *s* = (*initialSeed*^*m*) を設定するので、
*s* = prev(prev(prev(0)))^*m* = 164311266871034　を提供すると、
`nextDouble` の2回の呼び出し後に0となります。
しかし、それはあまりにも明確です。
100万個の前の値を、もちろん、ストリームを使用して生成し、最小のシードを見つけなさい。
ヒント：`nextDouble` を376050回呼び出した後に0を得ます。

### 柴田さん

問題文にある漸化式を書いて、`LongStream.iterate` で繰り返し呼び出す。
最小のシードは 881498 となる。